(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('chart.js'), require('@angular/core'), require('rxjs'), require('lodash')) :
    typeof define === 'function' && define.amd ? define('ng2-charts', ['exports', 'chart.js', '@angular/core', 'rxjs', 'lodash'], factory) :
    (factory((global['ng2-charts'] = {}),global.chart_js,global.ng.core,global.rxjs,global._));
}(this, (function (exports,chartJs,i0,rxjs,_) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var defaultColors = [
        [255, 99, 132],
        [54, 162, 235],
        [255, 206, 86],
        [231, 233, 237],
        [75, 192, 192],
        [151, 187, 205],
        [220, 220, 220],
        [247, 70, 74],
        [70, 191, 189],
        [253, 180, 92],
        [148, 159, 177],
        [77, 83, 96]
    ];

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Generate colors by chart type
     * @param {?} chartType
     * @param {?} index
     * @param {?} count
     * @return {?}
     */
    function getColors(chartType, index, count) {
        if (chartType === 'pie' || chartType === 'doughnut') {
            return formatPieColors(generateColors(count));
        }
        if (chartType === 'polarArea') {
            return formatPolarAreaColors(generateColors(count));
        }
        if (chartType === 'line' || chartType === 'radar') {
            return formatLineColor(generateColor(index));
        }
        if (chartType === 'bar' || chartType === 'horizontalBar') {
            return formatBarColor(generateColor(index));
        }
        if (chartType === 'bubble') {
            return formatPieColors(generateColors(count));
        }
        if (chartType === 'scatter') {
            return formatPieColors(generateColors(count));
        }
        throw new Error("getColors - Unsupported chart type " + chartType);
    }
    /**
     * @param {?} colour
     * @param {?} alpha
     * @return {?}
     */
    function rgba(colour, alpha) {
        return 'rgba(' + colour.concat(alpha).join(',') + ')';
    }
    /**
     * @param {?} min
     * @param {?} max
     * @return {?}
     */
    function getRandomInt(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }
    /**
     * @param {?} colors
     * @return {?}
     */
    function formatLineColor(colors) {
        return {
            backgroundColor: rgba(colors, 0.4),
            borderColor: rgba(colors, 1),
            pointBackgroundColor: rgba(colors, 1),
            pointBorderColor: '#fff',
            pointHoverBackgroundColor: '#fff',
            pointHoverBorderColor: rgba(colors, 0.8)
        };
    }
    /**
     * @param {?} colors
     * @return {?}
     */
    function formatBarColor(colors) {
        return {
            backgroundColor: rgba(colors, 0.6),
            borderColor: rgba(colors, 1),
            hoverBackgroundColor: rgba(colors, 0.8),
            hoverBorderColor: rgba(colors, 1)
        };
    }
    /**
     * @param {?} colors
     * @return {?}
     */
    function formatPieColors(colors) {
        return {
            backgroundColor: colors.map(( /**
             * @param {?} color
             * @return {?}
             */function (color) { return rgba(color, 0.6); })),
            borderColor: colors.map(( /**
             * @return {?}
             */function () { return '#fff'; })),
            pointBackgroundColor: colors.map(( /**
             * @param {?} color
             * @return {?}
             */function (color) { return rgba(color, 1); })),
            pointBorderColor: colors.map(( /**
             * @return {?}
             */function () { return '#fff'; })),
            pointHoverBackgroundColor: colors.map(( /**
             * @param {?} color
             * @return {?}
             */function (color) { return rgba(color, 1); })),
            pointHoverBorderColor: colors.map(( /**
             * @param {?} color
             * @return {?}
             */function (color) { return rgba(color, 1); }))
        };
    }
    /**
     * @param {?} colors
     * @return {?}
     */
    function formatPolarAreaColors(colors) {
        return {
            backgroundColor: colors.map(( /**
             * @param {?} color
             * @return {?}
             */function (color) { return rgba(color, 0.6); })),
            borderColor: colors.map(( /**
             * @param {?} color
             * @return {?}
             */function (color) { return rgba(color, 1); })),
            hoverBackgroundColor: colors.map(( /**
             * @param {?} color
             * @return {?}
             */function (color) { return rgba(color, 0.8); })),
            hoverBorderColor: colors.map(( /**
             * @param {?} color
             * @return {?}
             */function (color) { return rgba(color, 1); }))
        };
    }
    /**
     * @return {?}
     */
    function getRandomColor() {
        return [getRandomInt(0, 255), getRandomInt(0, 255), getRandomInt(0, 255)];
    }
    /**
     * Generate colors for line|bar charts
     * @param {?} index
     * @return {?}
     */
    function generateColor(index) {
        return defaultColors[index] || getRandomColor();
    }
    /**
     * Generate colors for pie|doughnut charts
     * @param {?} count
     * @return {?}
     */
    function generateColors(count) {
        /** @type {?} */
        var colorsArr = new Array(count);
        for (var i = 0; i < count; i++) {
            colorsArr[i] = defaultColors[i] || getRandomColor();
        }
        return colorsArr;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var ThemeService = /** @class */ (function () {
        function ThemeService() {
            this.pColorschemesOptions = {};
            this.colorschemesOptions = new rxjs.BehaviorSubject({});
        }
        /**
         * @param {?} options
         * @return {?}
         */
        ThemeService.prototype.setColorschemesOptions = /**
         * @param {?} options
         * @return {?}
         */
            function (options) {
                this.pColorschemesOptions = options;
                this.colorschemesOptions.next(options);
            };
        /**
         * @return {?}
         */
        ThemeService.prototype.getColorschemesOptions = /**
         * @return {?}
         */
            function () {
                return this.pColorschemesOptions;
            };
        ThemeService.decorators = [
            { type: i0.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */
        ThemeService.ctorParameters = function () { return []; };
        /** @nocollapse */ ThemeService.ngInjectableDef = i0.defineInjectable({ factory: function ThemeService_Factory() { return new ThemeService(); }, token: ThemeService, providedIn: "root" });
        return ThemeService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var BaseChartDirective = /** @class */ (function () {
        function BaseChartDirective(element, themeService) {
            this.element = element;
            this.themeService = themeService;
            this.options = {};
            this.chartClick = new i0.EventEmitter();
            this.chartHover = new i0.EventEmitter();
            this.initFlag = false;
            this.subs = [];
        }
        /**
         * Register a plugin.
         */
        /**
         * Register a plugin.
         * @param {?} plugin
         * @return {?}
         */
        BaseChartDirective.registerPlugin = /**
         * Register a plugin.
         * @param {?} plugin
         * @return {?}
         */
            function (plugin) {
                chartJs.Chart.plugins.register(plugin);
            };
        /**
         * @param {?} plugin
         * @return {?}
         */
        BaseChartDirective.unregisterPlugin = /**
         * @param {?} plugin
         * @return {?}
         */
            function (plugin) {
                chartJs.Chart.plugins.unregister(plugin);
            };
        /**
         * @return {?}
         */
        BaseChartDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.ctx = this.element.nativeElement.getContext('2d');
                this.initFlag = true;
                if (this.data || this.datasets) {
                    this.refresh();
                }
                this.subs.push(this.themeService.colorschemesOptions.subscribe(( /**
                 * @param {?} r
                 * @return {?}
                 */function (r) { return _this.themeChanged(r); })));
            };
        /**
         * @private
         * @param {?} options
         * @return {?}
         */
        BaseChartDirective.prototype.themeChanged = /**
         * @private
         * @param {?} options
         * @return {?}
         */
            function (options) {
                this.refresh();
            };
        /**
         * @param {?} changes
         * @return {?}
         */
        BaseChartDirective.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                if (this.initFlag) {
                    /** @type {?} */
                    var updateRequired = false;
                    // Check if the changes are in the data or datasets or labels or legend
                    if (changes.hasOwnProperty('data') || changes.hasOwnProperty('datasets')) {
                        if (changes.data) {
                            this.updateChartData(changes.data.currentValue);
                        }
                        else {
                            this.updateChartData(changes.datasets.currentValue);
                        }
                        updateRequired = true;
                    }
                    if (changes.hasOwnProperty('labels')) {
                        this.chart.data.labels = changes.labels.currentValue;
                        updateRequired = true;
                    }
                    if (changes.hasOwnProperty('legend')) {
                        this.chart.config.options.legend.display = changes.legend.currentValue;
                        this.chart.generateLegend();
                        updateRequired = true;
                    }
                    if (updateRequired) {
                        // ... if so, update chart
                        this.chart.update();
                    }
                    else {
                        // otherwise rebuild the chart
                        this.refresh();
                    }
                }
            };
        /**
         * @return {?}
         */
        BaseChartDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                if (this.chart) {
                    this.chart.destroy();
                    this.chart = void 0;
                }
                this.subs.forEach(( /**
                 * @param {?} x
                 * @return {?}
                 */function (x) { return x.unsubscribe(); }));
            };
        /**
         * @param {?=} duration
         * @param {?=} lazy
         * @return {?}
         */
        BaseChartDirective.prototype.update = /**
         * @param {?=} duration
         * @param {?=} lazy
         * @return {?}
         */
            function (duration, lazy) {
                return this.chart.update(duration, lazy);
            };
        /**
         * @param {?} index
         * @param {?} hidden
         * @return {?}
         */
        BaseChartDirective.prototype.hideDataset = /**
         * @param {?} index
         * @param {?} hidden
         * @return {?}
         */
            function (index, hidden) {
                this.chart.getDatasetMeta(index).hidden = hidden;
                this.chart.update();
            };
        /**
         * @param {?} index
         * @return {?}
         */
        BaseChartDirective.prototype.isDatasetHidden = /**
         * @param {?} index
         * @return {?}
         */
            function (index) {
                return this.chart.getDatasetMeta(index).hidden;
            };
        /**
         * @return {?}
         */
        BaseChartDirective.prototype.toBase64Image = /**
         * @return {?}
         */
            function () {
                return this.chart.toBase64Image();
            };
        /**
         * @param {?} ctx
         * @return {?}
         */
        BaseChartDirective.prototype.getChartBuilder = /**
         * @param {?} ctx
         * @return {?}
         */
            function (ctx /*, data:any[], options:any*/) {
                var _this = this;
                /** @type {?} */
                var datasets = this.getDatasets();
                /** @type {?} */
                var options = Object.assign({}, this.options);
                if (this.legend === false) {
                    options.legend = { display: false };
                }
                // hook for onHover and onClick events
                options.hover = options.hover || {};
                if (!options.hover.onHover) {
                    options.hover.onHover = ( /**
                     * @param {?} event
                     * @param {?} active
                     * @return {?}
                     */function (event, active) {
                        if (active && !active.length) {
                            return;
                        }
                        _this.chartHover.emit({ event: event, active: active });
                    });
                }
                if (!options.onClick) {
                    options.onClick = ( /**
                     * @param {?=} event
                     * @param {?=} active
                     * @return {?}
                     */function (event, active) {
                        _this.chartClick.emit({ event: event, active: active });
                    });
                }
                /** @type {?} */
                var mergedOptions = this.smartMerge(options, this.themeService.getColorschemesOptions());
                /** @type {?} */
                var chartConfig = {
                    type: this.chartType,
                    data: {
                        labels: this.labels,
                        datasets: datasets
                    },
                    plugins: this.plugins,
                    options: mergedOptions,
                };
                return new chartJs.Chart(ctx, chartConfig);
            };
        /**
         * @param {?} options
         * @param {?} overrides
         * @param {?=} level
         * @return {?}
         */
        BaseChartDirective.prototype.smartMerge = /**
         * @param {?} options
         * @param {?} overrides
         * @param {?=} level
         * @return {?}
         */
            function (options, overrides, level) {
                var _this = this;
                if (level === void 0) {
                    level = 0;
                }
                if (level === 0) {
                    options = _.cloneDeep(options);
                }
                /** @type {?} */
                var keysToUpdate = Object.keys(overrides);
                keysToUpdate.forEach(( /**
                 * @param {?} key
                 * @return {?}
                 */function (key) {
                    if (Array.isArray(overrides[key])) {
                        /** @type {?} */
                        var arrayElements = options[key];
                        if (arrayElements) {
                            arrayElements.forEach(( /**
                             * @param {?} r
                             * @return {?}
                             */function (r) {
                                _this.smartMerge(r, overrides[key][0], level + 1);
                            }));
                        }
                    }
                    else if (typeof (overrides[key]) === 'object') {
                        if (!(key in options)) {
                            options[key] = {};
                        }
                        _this.smartMerge(options[key], overrides[key], level + 1);
                    }
                    else {
                        options[key] = overrides[key];
                    }
                }));
                if (level === 0) {
                    return options;
                }
            };
        /**
         * @private
         * @param {?} v
         * @return {?}
         */
        BaseChartDirective.prototype.isChartDataSetsArray = /**
         * @private
         * @param {?} v
         * @return {?}
         */
            function (v) {
                /** @type {?} */
                var elm = v[0];
                return (typeof (elm) === 'object') && 'data' in elm;
            };
        /**
         * @private
         * @param {?} label
         * @return {?}
         */
        BaseChartDirective.prototype.isMultiLineLabel = /**
         * @private
         * @param {?} label
         * @return {?}
         */
            function (label) {
                return Array.isArray(label);
            };
        /**
         * @private
         * @param {?} label
         * @return {?}
         */
        BaseChartDirective.prototype.joinLabel = /**
         * @private
         * @param {?} label
         * @return {?}
         */
            function (label) {
                if (!label) {
                    return null;
                }
                if (this.isMultiLineLabel(label)) {
                    return label.join(' ');
                }
                else {
                    return label;
                }
            };
        /**
         * @private
         * @param {?} newDataValues
         * @return {?}
         */
        BaseChartDirective.prototype.updateChartData = /**
         * @private
         * @param {?} newDataValues
         * @return {?}
         */
            function (newDataValues) {
                var _this = this;
                if (this.isChartDataSetsArray(newDataValues)) {
                    if (newDataValues.length === this.chart.data.datasets.length) {
                        this.chart.data.datasets.forEach(( /**
                         * @param {?} dataset
                         * @param {?} i
                         * @return {?}
                         */function (dataset, i) {
                            dataset.data = newDataValues[i].data;
                            if (newDataValues[i].label) {
                                dataset.label = newDataValues[i].label;
                            }
                        }));
                    }
                    else {
                        this.chart.data.datasets = __spread(newDataValues);
                    }
                }
                else if (!this.isSingleDataSet(newDataValues)) {
                    if (newDataValues.length === this.chart.data.datasets.length) {
                        this.chart.data.datasets.forEach(( /**
                         * @param {?} dataset
                         * @param {?} i
                         * @return {?}
                         */function (dataset, i) {
                            dataset.data = newDataValues[i];
                        }));
                    }
                    else {
                        this.chart.data.datasets = newDataValues.map(( /**
                         * @param {?} data
                         * @param {?} index
                         * @return {?}
                         */function (data, index) {
                            return { data: data, label: _this.joinLabel(_this.labels[index]) || "Label " + index };
                        }));
                    }
                }
                else {
                    this.chart.data.datasets[0].data = newDataValues;
                }
                this.chart.data.datasets.forEach(( /**
                 * @param {?} elm
                 * @param {?} index
                 * @return {?}
                 */function (elm, index) {
                    if (_this.colors && _this.colors[index]) {
                        Object.assign(elm, _this.colors[index]);
                    }
                    else {
                        Object.assign(elm, getColors(_this.chartType, index, elm.data.length));
                    }
                }));
            };
        /**
         * @private
         * @param {?} data
         * @return {?}
         */
        BaseChartDirective.prototype.isSingleDataSet = /**
         * @private
         * @param {?} data
         * @return {?}
         */
            function (data) {
                return !Array.isArray(data[0]);
            };
        /**
         * @private
         * @return {?}
         */
        BaseChartDirective.prototype.getDatasets = /**
         * @private
         * @return {?}
         */
            function () {
                var _this = this;
                /** @type {?} */
                var datasets = void 0;
                // in case if datasets is not provided, but data is present
                if (!this.datasets || !this.datasets.length && (this.data && this.data.length)) {
                    if (!this.isSingleDataSet(this.data)) {
                        datasets = this.data.map(( /**
                         * @param {?} data
                         * @param {?} index
                         * @return {?}
                         */function (data, index) {
                            return { data: data, label: _this.joinLabel(_this.labels[index]) || "Label " + index };
                        }));
                    }
                    else {
                        datasets = [{ data: this.data, label: "Label 0" }];
                    }
                }
                if (this.datasets && this.datasets.length ||
                    (datasets && datasets.length)) {
                    datasets = (this.datasets || datasets)
                        .map(( /**
                 * @param {?} elm
                 * @param {?} index
                 * @return {?}
                 */function (elm, index) {
                        /** @type {?} */
                        var newElm = Object.assign({}, elm);
                        if (_this.colors && _this.colors.length) {
                            Object.assign(newElm, _this.colors[index]);
                        }
                        else {
                            Object.assign(newElm, getColors(_this.chartType, index, newElm.data.length));
                        }
                        return newElm;
                    }));
                }
                if (!datasets) {
                    throw new Error("ng-charts configuration error,\n      data or datasets field are required to render char " + this.chartType);
                }
                return datasets;
            };
        /**
         * @private
         * @return {?}
         */
        BaseChartDirective.prototype.refresh = /**
         * @private
         * @return {?}
         */
            function () {
                // if (this.options && this.options.responsive) {
                //   setTimeout(() => this.refresh(), 50);
                // }
                // todo: remove this line, it is producing flickering
                if (this.chart) {
                    this.chart.destroy();
                    this.chart = void 0;
                }
                this.chart = this.getChartBuilder(this.ctx /*, data, this.options*/);
            };
        BaseChartDirective.decorators = [
            { type: i0.Directive, args: [{
                        // tslint:disable-next-line:directive-selector
                        selector: 'canvas[baseChart]',
                        exportAs: 'base-chart'
                    },] }
        ];
        /** @nocollapse */
        BaseChartDirective.ctorParameters = function () {
            return [
                { type: i0.ElementRef },
                { type: ThemeService }
            ];
        };
        BaseChartDirective.propDecorators = {
            data: [{ type: i0.Input }],
            datasets: [{ type: i0.Input }],
            labels: [{ type: i0.Input }],
            options: [{ type: i0.Input }],
            chartType: [{ type: i0.Input }],
            colors: [{ type: i0.Input }],
            legend: [{ type: i0.Input }],
            plugins: [{ type: i0.Input }],
            chartClick: [{ type: i0.Output }],
            chartHover: [{ type: i0.Output }]
        };
        return BaseChartDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var ChartsModule = /** @class */ (function () {
        function ChartsModule() {
        }
        ChartsModule.decorators = [
            { type: i0.NgModule, args: [{
                        declarations: [
                            BaseChartDirective
                        ],
                        imports: [],
                        exports: [
                            BaseChartDirective
                        ]
                    },] }
        ];
        return ChartsModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    exports.ChartsModule = ChartsModule;
    exports.BaseChartDirective = BaseChartDirective;
    exports.defaultColors = defaultColors;
    exports.ThemeService = ThemeService;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=ng2-charts.umd.js.map